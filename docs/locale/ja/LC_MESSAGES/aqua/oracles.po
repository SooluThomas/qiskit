msgid ""
msgstr ""
"Project-Id-Version: qiskitdocs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-16 17:21+0000\n"
"PO-Revision-Date: 2019-07-16 17:36\n"
"Last-Translator: lzdanski\n"
"Language-Team: Japanese\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: crowdin.com\n"
"X-Crowdin-Project: qiskitdocs\n"
"X-Crowdin-Language: ja\n"
"X-Crowdin-File: /poRepo/docs/locale/en/LC_MESSAGES/aqua/oracles.po\n"
"Language: ja_JP\n"

#: ../../aqua/oracles.rst:5
msgid "Oracles"
msgstr ""

#: ../../aqua/oracles.rst:7
msgid "An oracle is a black box operation used as input to another algorithm. They tend to encode a function :math:`f:\\{0,1\\}^n \\rightarrow \\{0,1\\}^m` where the goal of the algorithm is to determine some property of :math:`f`."
msgstr ""

#: ../../aqua/oracles.rst:11
msgid "The following quantum oracles are included in Aqua:"
msgstr ""

#: ../../aqua/oracles.rst:13
msgid ":ref:`logical-expression-oracle`"
msgstr ""

#: ../../aqua/oracles.rst:14
msgid ":ref:`truth-table-oracle`"
msgstr ""

#: ../../aqua/oracles.rst:15
msgid ":ref:`custom-circuit-oracle`"
msgstr ""

msgid "Extending the Oracle Library"
msgstr ""

#: ../../aqua/oracles.rst:19
msgid "Consistent with its unique design, Aqua has a modular and extensible architecture. Algorithms and their supporting objects, such as oracles, are pluggable modules in Aqua, and are able to be used in a plug-and-play fashion, when appropriate. For example, The Grover's Search algorithm would be able to take any single-valued binary oracles, while the Deutsch Jozsa algorithm can work on single-valued oracles that represent constant or balanced functions only."
msgstr ""

#: ../../aqua/oracles.rst:28
msgid "New oracles are typically installed in the ``qiskit/aqua/components/oracles`` folder and derive from the ``Oracle`` class. Aqua also allows for :ref:`aqua-dynamically-discovered-components`: new components can register themselves as Aqua extensions and be dynamically discovered at run time independent of their location in the file system. This is done in order to encourage researchers and developers interested in :ref:`aqua-extending` to extend the Aqua framework with their novel research contributions."
msgstr ""

#: ../../aqua/oracles.rst:38
msgid ":ref:`aqua-extending` provides more details on how to extend Aqua with new components."
msgstr ""

#: ../../aqua/oracles.rst:45
msgid "Logical Expression Oracle"
msgstr ""

#: ../../aqua/oracles.rst:47
msgid "The Logical Expression Oracle, as its name suggests, constructs circuits for any arbitrary input logical expressions. A logical expression is composed of logical operators ``&`` (``AND``), ``|`` (``OR``), ``~`` (``NOT``), and ``^`` (``XOR``), as well as symbols for literals (variables). For example, ``'a & b'``, and ``(v0 | ~v1) ^ (~v2 & v3)`` are both valid string representation of boolean logical expressions."
msgstr ""

#: ../../aqua/oracles.rst:60
msgid "For convenience, this oracle, in addition to trying to parse arbitrary logical expressions, also supports input strings in the `DIMACS CNF format <http://www.satcompetition.org/2009/format-benchmarks2009.html>`__, which is the standard format for specifying SATisfiability (SAT) problem instances in `Conjunctive Normal Form (CNF) <https://en.wikipedia.org/wiki/Conjunctive_normal_form>`__, which is a conjunction of one or more clauses, where a clause is a disjunction of one or more literals."
msgstr ""

#: ../../aqua/oracles.rst:71
msgid "The following is an example of a CNF expressed in DIMACS format:"
msgstr ""

#: ../../aqua/oracles.rst:83
msgid "The first line, following the ``c`` character, is a comment. The second line specifies that the CNF is over three boolean variables --- let us call them :math:`x_1, x_2, x_3`, and contains five clauses.  The five clauses, listed afterwards, are implicitly joined by the logical ``AND`` operator, :math:`\\land`, while the variables in each clause, represented by their indices, are implicitly disjoined by the logical ``OR`` operator, :math:`lor`. The :math:`-` symbol preceding a boolean variable index corresponds to the logical ``NOT`` operator, :math:`lnot`.  Character ``0`` marks the end of each clause.  Essentially, the code above corresponds to the following CNF: :math:`(\\lnot x_1 \\lor \\lnot x_2 \\lor \\lnot x_3) \\land (x_1 \\lor \\lnot x_2 \\lor x_3) \\land (x_1 \\lor x_2 \\lor \\lnot x_3) \\land (x_1 \\lor \\lnot x_2 \\lor \\lnot x_3) \\land (\\lnot x_1 \\lor x_2 \\lor x_3)`."
msgstr ""

#: ../../aqua/oracles.rst:98
msgid "An example showing how to use the Grover algorithm on a DIMACS oracle to search for a satisfying assignment to an SAT problem encoded in DIMACS is available in the ``optimization`` folder of the `Qiskit Tutorials GitHub repository <https://github.com/Qiskit/qiskit-tutorials/tree/master/community/aqua>`__."
msgstr ""

#: ../../aqua/oracles.rst:104
msgid "Logic expressions, regardless of the input formats, are parsed and stored as Abstract Syntax Tree (AST) tuples, from which the corresponding circuits are constructed. The oracle circuits can then be used with any oracle-oriented algorithms when appropriate. For example, an oracle built from a DIMACS input can be used with the Grover's algorithm to search for a satisfying assignment to the encoded SAT instance."
msgstr ""

msgid "Circuit Optimization"
msgstr ""

#: ../../aqua/oracles.rst:115
msgid "By default, Aqua's logical expression oracle would not try to apply any optimization when building the circuits. For any ``DIMACS`` input, the constructed circuit truthfully recreates each inner disjunctive clauses as well as the outermost conjunction; For other arbitrary input expression, Aqua only tries to convert it to a CNF or DNF (Disjunctive Normal Form, similar to CNF, but with inner conjunctions and a outer disjunction) before constructing its circuit. This, for example, could be good for educational purposes, where a user would like to compare a built circuit against their input expression to examine and analyze details. However, this oftentimes leads to relatively deep circuits that possibly also involve many ancillary qubits. Aqua, therefore, provides the option to try to optimize the input logical expression before building its circuit."
msgstr ""

#: ../../aqua/oracles.rst:135
msgid "When omitted, it will default to ``False``, indicating no optimization."
msgstr ""

#: ../../aqua/oracles.rst:137
msgid "Internally, the logical expression oracle relies heavily on ``mct``, the Multiple-Control Toffoli operation, for circuit constructions. Aqua includes multiple different modes for ``mct``, namely ``'basic'``, ``'basic-dirty-ancilla'``, ``'advanced'``, and ``'noancilla'``:"
msgstr ""

#: ../../aqua/oracles.rst:146
msgid "More information on ``mct`` and its various modes can be found at :ref:`mct`."
msgstr ""

msgid "Declarative Name"
msgstr ""

#: ../../aqua/oracles.rst:150
msgid "When referring to the logical expression oracle declaratively inside Aqua, its code ``name``, by which Aqua dynamically discovers and loads it, is ``LogicExpressionOracle``."
msgstr ""

#: ../../aqua/oracles.rst:159
msgid "Truth Table Oracle"
msgstr ""

#: ../../aqua/oracles.rst:161
msgid "Besides logical expressions, another common way of specifying boolean functions is using truth tables, which is basically an exhaustive mapping from input binary bit-strings of length :math:`n` to corresponding output bit-strings of length :math:`m`. For example, the following is a simple truth table that corresponds to the ``XOR`` of two variables:"
msgstr ""

#: ../../aqua/oracles.rst:171
msgid "Inputs"
msgstr ""

#: ../../aqua/oracles.rst:171
msgid "Output"
msgstr ""

#: ../../aqua/oracles.rst:173
msgid "``A``"
msgstr ""

#: ../../aqua/oracles.rst:173
msgid "``B``"
msgstr ""

#: ../../aqua/oracles.rst:173
msgid "``A xor B``"
msgstr ""

#: ../../aqua/oracles.rst:175 ../../aqua/oracles.rst:176
#: ../../aqua/oracles.rst:177 ../../aqua/oracles.rst:178
msgid "0"
msgstr ""

#: ../../aqua/oracles.rst:176 ../../aqua/oracles.rst:177
#: ../../aqua/oracles.rst:178
msgid "1"
msgstr ""

#: ../../aqua/oracles.rst:181
msgid "In this case :math:`n=2`, and :math:`m=1`. Oftentimes, for brevity, the input bit-strings are omitted because they can be easily derived for any given :math:`n`. So to completely specify a truth table, we only need a Length-2 :sup:`n` bit-string for each of the :math:`m` outputs. In the above example, a single bit-string ``'0110'`` would suffice. Besides ``'0'`` and ``'1'``, one can also use ``'x'`` in the output string to indicate ``'do-not-care'`` entries. For example, ``'101x'`` specifies a truth table (again :math:`n=2` and :math:`m=1`) for which the output upon input ``'11'`` doesn't matter. Aqua's truth table oracle takes either a single string or a list of equal-length strings for truth table specifications."
msgstr ""

#: ../../aqua/oracles.rst:199
#, python-format
msgid "Regarding circuit optimization and mct usages, the truth table oracle is similar to the logical expression oracle. So the parameters ``optimization`` and ``mct_mode`` can also be supplied here. One difference is that, unlike the logical expression oracle who builds circuits out of CNF or DNF, the truth table oracle uses Exclusive Sum of Products (ESOP), which is similar to DNF, with the only difference being the outermost operation being ``XOR`` as opposed to a disjunction. Because of this difference, an implicant-based method is used here for circuit optimization: First, the `Quine-McCluskey algorithm <https://en.wikipedia.org/wiki/Quine-McCluskey_algorithm>`__ is used to find all prime implicants of the input truth table; then an `Exact Cover <https://en.wikipedia.org/wiki/Knuth%27s_Algorithm_X>`__ is found among all prime implicants and truth table onset row entries. The exact cover is then used to build the corresponding oracle circuit."
msgstr ""

#: ../../aqua/oracles.rst:223
msgid "When omitted, it will default to False, indicating no optimization."
msgstr ""

#: ../../aqua/oracles.rst:227
msgid "When referring to the Truth Table Oracle declaratively inside Aqua, its code ``name``, by which Aqua dynamically discovers and loads it, is ``TruthTableOracle``."
msgstr ""

#: ../../aqua/oracles.rst:236
msgid "Custom Circuit Oracle"
msgstr ""

#: ../../aqua/oracles.rst:238
msgid "This class is provided for easy creation of oracles using custom circuits. It is geared towards programmatically experimenting with oracles, where a user would directly provide a ``QuantumCircuit`` object corresponding to the intended oracle function, together with the various ``QuantumRegister`` objects involved."
msgstr ""

